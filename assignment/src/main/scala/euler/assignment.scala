package euler

object ProjectEuler {
  /*
   * Even Fibonacci numbers
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous
   * two terms. By starting with 1 and 2, the first 10 terms will be:
   *
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   *
   * By considering the terms in the Fibonacci sequence whose values do not
   * exceed four million, find the sum of the even-valued terms.
   */
  def problem2(): Int = { 
      println("hello problem 2")
     
      def sum2Ints(num1:Int, num2:Int): Int = {
           num1+num2
      }
       
      def evenFibonanci(x:Int,y:Int,evenSum:Int): Int = {
          
           val nextFib = sum2Ints(x,y)
           
           //println("x y nextfib " + x + " " + y + " " + nextFib)
           if(y >= 4000000){
               evenSum
           } else if(y % 2 == 0){
               evenFibonanci(y,nextFib,evenSum+y)
           } else {
               evenFibonanci(y,nextFib,evenSum)
           }
           
       }
       evenFibonanci(1:Int,2:Int,0:Int)
  }
  /*
   * Largest palindrome product
   *
   * A palindromic number reads the same both ways. The largest palindrome made
   * from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   *
   * Find the largest palindrome made from the product of two 3-digit numbers.
   *
   */
  def problem4(): Int = {
       
        def isPalidrome(charNumbers:List[Char]): Boolean = {
            // really vulnerable function that recursively checks if list has
            // same head as last member. If list is smaller than 1 size or empty
            // that means that it is palidrome, not functional if you send list of size 1
            // but hey, you should know that list of one cannot be palidrome!!!
            
            val listSize = charNumbers.size
            
            if(listSize <= 1 || charNumbers.isEmpty){
                println("IS PALIDROME >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
                true
            } else {
                if(charNumbers.head != charNumbers.reverse.head){
                    false
                } else {
                    
                    val remfirst = charNumbers.tail
                    val remlast = remfirst.reverse.tail
                    isPalidrome(remlast)
                    
                }
            }
        }
        
        def threeDigitPalidrome(num1:Int, num2:Int, largestPalidrome:Int): Int = {
            
            if(num1 == 100 && num2 == 100){
                largestPalidrome
            } else {
                val prod = num1 * num2
                // we need to convert it to string and then to list so that it can be "looped"
                val prodToList = prod.toString.toList
                
                if(isPalidrome(prodToList) && prod > largestPalidrome){
                    println("num1 and num 2, IS palidrome = " +num1+" " +num2)
                    if(num1 == 100){
                        threeDigitPalidrome(num2-1,num2-1,prod)
                    } else {
                        threeDigitPalidrome(num1-1,num2,prod)
                    }
                } else {
                    if(num1 == 100){
                        threeDigitPalidrome(num2-1,num2-1,largestPalidrome)
                    } else {
                        threeDigitPalidrome(num1-1,num2,largestPalidrome)
                    }
                }
            }
        }
        // start with the highest 3-digit numbers = 999*999
        // added every second boolean. If true then add to first number +1 and so on
        threeDigitPalidrome(999,999,0)
    }

  /*
   * Special Pythagorean triplet
   *
   * A Pythagorean triplet is a set of three natural numbers, a < b < c, for
   * which, a^2 + b^2 = c^2
   *
   * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   */
  def problem9(): Int = ???


  /*
   * Maximum path sum I
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *      3
   *     7 4
   *    2 4 6
   *   8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom of the given triangle with 15
   * rows:
   */
   
   // I REALLY CAN'T FIGURE THIS OUT GOING TOP TO BOTTOM SO I TRIED SOMETHING ELSE
   // AND I DID NOT WAN'T TO USE BRUTAL FORCE
 def problem18(triangle: List[List[Int]]): Int = {
    // take the last-list and sum it with the best path of the last lists elements
    // it is called falsely lastList -element because it is reversed so actually the first list element
  
    val rTriangle = triangle.reverse
    
    def greatestSumOfLists (x:Int,list1:List[Int],list2:List[Int],sumList:List[Int]): List[Int] = {
        
        if(x >= list2.size-1){
            sumList
        } else {
            val greatestSum = list2(x) + scala.math.max(list1(x),list2(x+1))
            greatestSumOfLists(x+1,list1,list2, greatestSum :: sumList)
        }
    }
    
    
    if(triangle.tail.length == 1){
        val firstElement = triangle.head
        val secondElement = triangle.reverse.head
        firstElement(0) + secondElement(0)
        
        
    } else {
        
        val total = greatestSumOfLists(0, rTriangle.head, rTriangle.tail.head, List())
        println(total)
        // remove first 2 list from the triangle and put sumlist into it
        val firstRemove = rTriangle.tail
        val secondRemove = firstRemove.tail
        
        // call itself to calculate next row sum
        val finalList = total :: secondRemove
    
        problem18(finalList.reverse)
    }
  }

  /*
   * Maximum path sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom in the given triangle with
   * one-hundred rows.
   *
   * NOTE: This is a much more difficult version of Problem 18. It is not
   * possible to try every route to solve this problem, as there are 2^99
   * altogether! If you could check one trillion (10^12) routes every second it
   * would take over twenty billion years to check them all. There is an
   * efficient algorithm to solve it. ;o)
   */
  def problem67(triangle: List[List[Int]]): Int = {
      problem18(triangle)
  }
}
